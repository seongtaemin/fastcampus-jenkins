pipeline {
    // 어떠한 에이전트에서도 실행 가능함을 표현
    agent any



    environment {
        // 사용자 설정 반영
        HARBOR_URL = 'harbor.kolon.local'
        GITOPS_REPO_URL = 'https://github.com/seongtaemin/3tier-app.git'
        ARGOCD_SERVER = '172.18.229.174:30002'
        
        // 프로젝트 및 이미지 설정
        HARBOR_PROJECT = 'library'
        
        // SonarQube 설정 (Tool Name)
        SONAR_SCANNER_HOME = tool name: 'sonar-scanner', type: 'hudson.plugins.sonar.SonarRunnerInstallation'
        
        // GitConfig
        GIT_USER_EMAIL = 'taemni.seong@gmail.com'
        GIT_USER_NAME = 'seongtaemin'
    }

    stages {
        stage('Initialize') {
            steps {
                script {
                    echo "Initializing pipeline..."
                    
                    def userInput = input(
                        message: 'Enter Application Details', 
                        parameters: [
                            string(defaultValue: '3tier-app', description: 'Application Name', name: 'APP_NAME'),
                            string(defaultValue: '3tier-app', description: 'Target Namespace', name: 'TARGET_NAMESPACE', trim: true)
                        ]
                    )
                    env.APP_NAME = userInput['APP_NAME']
                    env.TARGET_NAMESPACE = userInput['TARGET_NAMESPACE']
                    
                    echo "App Name: ${env.APP_NAME}"
                    echo "Target Namespace: ${env.TARGET_NAMESPACE}"
                    echo "Harbor URL: ${HARBOR_URL}"
                    echo "ArgoCD Server: ${ARGOCD_SERVER}"
                    
                    // GitOps 리포지토리 클론
                    sh "rm -rf gitops-repo && git clone ${GITOPS_REPO_URL} gitops-repo"
                    
                    // 모든 YAML 파일에서 image: 항목을 재귀적으로 탐색하여 이미지 이름과 버전 추출
                    // 형식: "파일경로|이미지이름|버전" (한 줄에 하나씩)
                    def imageLines = sh(
                        script: '''
                            find gitops-repo -name "*.yaml" -o -name "*.yml" | while read yamlFile; do
                                grep -n 'image:' "$yamlFile" | while IFS=: read lineNum lineContent; do
                                    # image: 뒤의 값 추출 (주석 제거)
                                    imageValue=$(echo "$lineContent" | sed 's/.*image:[[:space:]]*//' | sed 's/#.*//' | tr -d ' "'"'"'')
                                    
                                    # 이미지이름:태그 형식에서 분리
                                    if echo "$imageValue" | grep -q ':'; then
                                        # 레지스트리/프로젝트 경로 제거 후 순수 이미지 이름만 추출
                                        imageFull=$(echo "$imageValue" | rev | cut -d'/' -f1 | rev)
                                        imageName=$(echo "$imageFull" | cut -d':' -f1)
                                        imageTag=$(echo "$imageFull" | cut -d':' -f2)
                                        relPath=$(echo "$yamlFile" | sed 's|^gitops-repo/||')
                                        echo "${relPath}|${imageName}|${imageTag}"
                                    fi
                                done
                            done
                        ''',
                        returnStdout: true
                    ).trim()
                    
                    // imageLines를 ';' 구분자로 결합하여 환경변수에 저장
                    // 형식: "file1|name1|version1;file2|name2|version2;..."
                    if (!imageLines) {
                        error "GitOps 리포지토리에서 image 항목을 찾을 수 없습니다."
                    }
                    
                    // 줄바꿈을 ';'로 변환하여 단일 문자열로 저장
                    env.IMAGE_MAP_STR = imageLines.split('\n').collect { it.trim() }.findAll { it }.join(';')
                    
                    // 결과 출력
                    echo "========== 발견된 이미지 목록 =========="
                    env.IMAGE_MAP_STR.split(';').each { entry ->
                        def parts = entry.split('\\|')
                        if (parts.length == 3) {
                            echo "  파일: ${parts[0]} | 이미지: ${parts[1]} | 버전: ${parts[2]}"
                        }
                    }
                    echo "========================================"
                }
            }
        }

        stage('SonarQube Analysis') {
            steps {
                script {
                    withSonarQubeEnv('sonarqube-server') {
                        sh """
                        ${env.SONAR_SCANNER_HOME}/bin/sonar-scanner \
                            -Dsonar.host.url=http://sonarqube:9000 \
                            -Dsonar.projectKey=${APP_NAME} \
                            -Dsonar.projectBaseDir=. \
                            -Dsonar.sources=. \
                            -Dsonar.exclusions=vendor/**,node_modules/**,**/*.java,**/*.xml,**/*.yaml
                        """
                    }
                }
                timeout(time: 1, unit: 'MINUTES') {
                    waitForQualityGate abortPipeline: true
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: 'harbor-credentials', usernameVariable: 'HARBOR_USER', passwordVariable: 'HARBOR_PASSWORD')]) {
                        sh "docker login ${HARBOR_URL} -u \${HARBOR_USER} -p \${HARBOR_PASSWORD}"
                        
                        // 발견된 모든 이미지를 순회하면서 pull → tag → push
                        env.IMAGE_MAP_STR.split(';').each { entry ->
                            def parts = entry.split('\\|')
                            if (parts.length == 3) {
                                def imgName = parts[1]
                                def imgVersion = parts[2]
                                echo "=== ${imgName} 이미지 (${imgVersion}) ==="
                                sh """
                                    docker pull ${imgName}:${imgVersion}
                                    docker tag ${imgName}:${imgVersion} ${HARBOR_URL}/${HARBOR_PROJECT}/${imgName}:${imgVersion}
                                    docker push ${HARBOR_URL}/${HARBOR_PROJECT}/${imgName}:${imgVersion}
                                """
                            }
                        }
                    }
                }
            }
        }

        stage('Approval') {
            steps {
                script {
                    // 발견된 이미지 목록을 승인 메시지에 표시
                    def imageDesc = env.IMAGE_MAP_STR.split(';').collect { entry ->
                        def parts = entry.split('\\|')
                        parts.length == 3 ? "${parts[1]}:${parts[2]}" : ''
                    }.findAll { it }.join(', ')
                    
                    def userInput = input(
                        id: 'Deploy', 
                        message: '배포하시겠습니까?', 
                        parameters: [
                            [$class: 'BooleanParameterDefinition', defaultValue: true, description: '이미지 목록: ' + imageDesc, name: 'Proceed']
                        ]
                    )
                }
            }
        }

        stage('Argo Git Push') {
            steps {
                script {
                    withCredentials([
                        usernamePassword(credentialsId: 'github-token', usernameVariable: 'GIT_USER', passwordVariable: 'GIT_PASSWORD'),
                        usernamePassword(credentialsId: 'harbor-credentials', usernameVariable: 'HARBOR_USER', passwordVariable: 'HARBOR_PASSWORD')
                    ]) {
                        sh """
                            git config --global user.email "${GIT_USER_EMAIL}"
                            git config --global user.name "${GIT_USER_NAME}"
                            
                            rm -rf gitops-repo
                            git clone ${GITOPS_REPO_URL} gitops-repo
                            
                            cd gitops-repo
                            
                            # 모든 YAML 파일에서 namespace 값을 사용자가 입력한 값으로 일괄 변경
                            find . -name "*.yaml" -o -name "*.yml" | xargs -I {} sed -i 's/^\\([[:space:]]*\\)namespace:.*/\\1namespace: ${env.TARGET_NAMESPACE}/g' {}
                            
                            # namespace.yaml의 metadata.name 도 변경
                            if [ -f namespace.yaml ]; then
                                sed -i -e '/^metadata:/,/^  name:/ s/^  name:.*/  name: ${env.TARGET_NAMESPACE}/g' namespace.yaml
                            fi
                        """
                        
                        // 발견된 모든 이미지에 대해 YAML 파일의 image 태그를 Harbor 이미지로 변경
                        def changedFilesList = []
                        env.IMAGE_MAP_STR.split(';').each { entry ->
                            def parts = entry.split('\\|')
                            if (parts.length == 3) {
                                def imgFile = parts[0]
                                def imgName = parts[1]
                                def imgVersion = parts[2]
                                sh """
                                    cd gitops-repo
                                    sed -i 's|image: .*${imgName}:.*|image: ${HARBOR_URL}/${HARBOR_PROJECT}/${imgName}:${imgVersion}|' ${imgFile}
                                """
                                changedFilesList.add(imgFile)
                            }
                        }
                        
                        // 변경된 YAML 파일 목록 수집
                        def changedFiles = changedFilesList.unique().join(' ')
                        
                        sh """
                            cd gitops-repo
                            
                            # Generate harbor-credentials.yaml for ArgoCD to manage
                            AUTH=\$(echo -n "\${HARBOR_USER}:\${HARBOR_PASSWORD}" | base64)
                            DOCKER_CONFIG_JSON="{\\\"auths\\\":{\\\"${HARBOR_URL}\\\":{\\\"auth\\\":\\\"\${AUTH}\\\"}}}"
                            DOCKER_CONFIG_BASE64=\$(echo -n "\${DOCKER_CONFIG_JSON}" | base64 -w 0)
                            
                            cat <<EOF > harbor-credentials.yaml
apiVersion: v1
kind: Secret
metadata:
  name: harbor-credentials
type: kubernetes.io/dockerconfigjson
data:
  .dockerconfigjson: \${DOCKER_CONFIG_BASE64}
EOF
                            
                            git add . && git add harbor-credentials.yaml
                            # 변경사항이 있을 때만 커밋
                            git diff --quiet && git diff --staged --quiet || git commit -m "Ensure Manifests and Harbor Credentials"
                            
                            git push https://\${GIT_USER}:\${GIT_PASSWORD}@github.com/seongtaemin/3tier-app.git HEAD:main
                        """
                    }
                }
            }
        }

        stage('ArgoCD Sync') {
            steps {
                script {
                    sh """
                        # ArgoCD CLI 다운로드 시도 (서버에서 먼저 시도, 실패 시 GitHub에서 다운로드)
                        curl -sSL -o argocd --retry 3 --retry-delay 5 --max-time 30 https://${ARGOCD_SERVER}/download/argocd-linux-amd64 --insecure || \
                        curl -sSL -o argocd --retry 3 --retry-delay 5 --max-time 60 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
                        chmod +x argocd
                    """

                    withCredentials([
                        usernamePassword(credentialsId: 'argocd-credentials', usernameVariable: 'ARGO_USER', passwordVariable: 'ARGO_PASSWORD'),
                        usernamePassword(credentialsId: 'harbor-credentials', usernameVariable: 'HARBOR_USER', passwordVariable: 'HARBOR_PASSWORD')
                    ]) {
                        
                        // 1. 로그인
                        sh """
                            ./argocd login ${ARGOCD_SERVER} \
                                --username \${ARGO_USER} \
                                --password \${ARGO_PASSWORD} \
                                --plaintext \
                                --grpc-web
                        """

                        // 2. 클러스터 목록 조회 (헤더 제외하고 첫 번째 컬럼인 SERVER URL만 추출)
                        def clusters = sh(
                            script: "./argocd cluster list --plaintext --grpc-web | awk 'NR>1 {print \$1}'", 
                            returnStdout: true
                        ).trim().tokenize('\n')

                        // 3. 사용자에게 배포할 클러스터 및 네임스페이스 선택 요청
                        def userInput = input(
                            id: 'SelectClusterAndNamespace',
                            message: '배포할 Kubernetes 클러스터와 네임스페이스를 입력하세요:',
                            parameters: [
                                choice(name: 'DEST_SERVER', choices: clusters, description: 'Target Kubernetes Cluster URL')
                            ]
                        )
                        
                        def selectedCluster = userInput
                        def targetNamespace = env.TARGET_NAMESPACE
                        
                        echo "Selected Cluster: ${selectedCluster}"
                        echo "Target Namespace: ${targetNamespace}"


                        // 4. 선택된 클러스터 및 네임스페이스로 앱 생성 및 배포
                        sh """
                            ./argocd app create ${APP_NAME} \
                                --repo ${GITOPS_REPO_URL} \
                                --revision main \
                                --path . \
                                --dest-server ${selectedCluster} \
                                --dest-namespace ${targetNamespace} \
                                --sync-option CreateNamespace=true \
                                --upsert \
                                --plaintext \
                                --grpc-web

                            ./argocd app sync ${APP_NAME} \
                                --plaintext \
                                --grpc-web
                                
                            ./argocd app wait ${APP_NAME} \
                                --health \
                                --plaintext \
                                --grpc-web \
                                --timeout 300
                        """
                    }
                }
            }
        }
    }
}
